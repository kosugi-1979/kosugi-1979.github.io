---
layout: post
title: "ルータ自作でわかるパケットの流れ"
date: 2014-01-02 14:47
comments: true
categories: book network
---

ルータ自作とあるが、ルーティングのアルゴリズムには触れない。どちらかというとパケットに関する内容が主。

第2章以降はソースをベースに解説を加えていくスタイルであるにもかかわらず、C で書かれたソースが雑。また、そのソースに付けられている説明が簡素であること含めて「はじめに」で書かれている

* Linux での C言語プログラミング
* socket ネットワークプログラミング
* pthread マルチスレッドプログラミング
* Linux でのリンクレイヤープログラミング
* Ethernet/IP/ARP/ICMP/TCP/UDP の知識

を満たしていない人が読むのには全く向いていない。  

全体の構成は 5 章からなっている。

1 章はイントロダクションとして、この本で扱う内容の解説になっている。具体的にはブリッジやルータの役割や、パケットの構造を解説している。ただし本を読み進める上で最小限必要となる内容しか書かれていない。とはいえ、既にこのあたりのことに詳しい人を除けば先の章を読むにあたってはこの章を何度も読み返すことになる。

2 章から本番になり、まずは全体の基礎となるリンクレイヤでパケットを扱う方法を学ぶ。ここの内容は完全に Linux 前提になっている。一応、最後にあるコラムで *BSD, Solaris, Windows の場合についても少し触れているが、この情報だけで簡単にそれらの OS に移植できるようなものではないので、内容に集中するためにもやはり Linux 環境で読むのが良いと思う。

3 章ではパケットキャプチャを作成する。2 章でイーサネットのパケットの扱い方が分かっているので、後はパケットヘッダを見て何のプロトコルのパケットかを判断して表示するだけ。p.63 のフローチャートをそのままソースにしただけに近い。なお、TCP, UDP のヘッダの構造は本書に記載されていないので、別途調べておくと便利。この章は他と比べて長いが、判別、表示処理がパケット毎に異なる処理になっているためで、要領が分かってしまえば途中からは飛ばし読みでも十分。  
なお、ソースがパケット解析部を一通り記載した後で、表示部、チェックサム計算部となっているので、ARP なり ICMP 部分だけで良いからとりあえず動くように作ってその後で他のプロトコルにも対応しようとすると、ページを行ったり来たりすることになる。

4 章でブリッジを作成をする。ここで作成するブリッジは 2 つのネットワークインタフェースしか持たず、片方に入って来たパケットをもう片方にフォワーディングするだけのシンプルなものなので、ソース量も少ない。要は 2 つしかポートのないバカハブを作っているようなもの。一応スイッチングの仕組みも最後で触れているので、そちらにチャレンジすることも可能。  
ところで、この章の冒頭で

>一般的な PC にはネットワークインターフェースが 1 つしかついていないと思いますので、増設する必要があります。以前は PCI に増設する方法が主流でしたが、今なら USB のネットワークインターフェースも安価に販売されています。
>また、とりあえず実験してみたいということであれば、ノート PC であれば有線と無線のインターフェースがあることが多く、それでも十分でしょう。

と書かかれているが、せめて VirtualBox なり VMware なりでの実験環境の整備の仕方くらいは触れておくべきではないだろうか。もちろん、実マシンを用意できる人はそちらでやった方が実感が得られやすいだろうが、個人で簡単に用意できる人はおそらく少数派だろう。

 5章でついにルータのようなものを作る。つまり、ネットワークセグメントをまたぐパケットを扱う。今まではパケットを見るだけだったが、ここではパケットを加工する処理が発生する。例えば他セグメント宛パケットの場合に宛先となる MAC アドレスの書き換えなど。

 こうしてみると、全体の構成は

- パケットの構造
- ブログラムでのパケットの扱い方
- パケットの中身を見る
- パケットの送受信
- パケットの加工

という形で徐々にステップアップしながら進んでいくようになっていることが分かる。前の章を引き継いでいることから各章のプログラム間で重復が非常に多いのだが、この本ではいちいち全ソースコードを掲載している。どうせソースはネットで配布しているのだから、載せるのは差分だけにして空いたスペースで詳しい説明を記述してくれた方がありがたい。

最後に、読んでいて気になった部分を挙げておく。あくまで個人的なものなので人によってはまったく気にならないかもしれないが、内容理解に関係ないところで頭を使わされる機会が多かった。
例えば、p.47 に

	if(ipOnly){
		if((soc=socket(PF_PACKET,SOCK_ROW,htons(ETH_P_IP)))<0){
			perror("socket");
			return(-1);
		}
	}
	else{
		if((soc=socket(PF_PACKET,SOCK_ROW,htons(ETH_P_ALL)))<0){
			perror("socket");
			return(-1);
		}	
	}

というコードがあるのだが、よく見れば ipOnly の値によって変わるのは socket に渡す第三引数のみであると分かる。つまり、?: を用いて

	if((soc=socket(PF_PACKET,SOCK_ROW,htons(ipOnly ? ETH_P_IP : ETH_P_ALL)))<0){
		perror("socket");
		return(-1);
	}

と書けば、違っている個所が一目で分かり、いちいち読者の側で if ブロックの中身全体を見比べなくて済む。

p.89 には

    if(icmp->icmp_type==0||icmp->icmp->icmp_type==8){

とあるが、これはマクロがあるのだから

    if(icmp->icmp_type==ICMP_ECHOREPLY||icmp->icmp->icmp_type==ICMP_ECHO){

とすればより意図が伝わりやすい。マクロといえば

    if(ntohs(arp->arp_hrd)<=23)

のように配列外アクセスのチェックも

    #define ARRAY_SIZE(_a) (sizeof(_a)/sizeof((_a)[0]))

を定義した上で

    if(ntohs(arp->arp_hrd)<ARRAY_SIZE(hrd))

と記述するだけで読みやすさがかなり上がる。

他にも if-else if よりも switch を使った方が読みやすくなるなど、全体的に読む側に余計な脳の負担をかける記述になっている。どうせならもっと本質的な部分を理解するのに脳味噌を使いたいので、無駄に読みにくくしているのは残念。

また、プログラム実行方法が突き放しすぎ。実行結果のみで、その結果を得るのにどのような操作をしたのかすら全く書いていない。この部分は正しく動いているかを確認する意味もある部分なので、もう少し丁寧に記述してくれても良かったのではないだろうか。

他、どうでも良い些細言なことだがソースで気になった部分。

1. 取って付けたような、コメント一切なしの header 
2. u_int16_t を unsigned short で受けている。両方とも符号なし 16bit 整数型だから問題ないといえばそうなのだが、異なる型名は異なる役割を持つはずなので、理由なくこのようなことをしていると違和感がある。
3. const を付けてない。print 系の関数など、ポインタを受けて表示し、その内容に変更を加えることのない場合には const を付けるのが基本だが、この本では全く const を使っていない。こういった書き方は古くから C 言語を使っていて C++ は知らないという人に多い気がする。
4. 残りバイト数を保持する変数名が lest となっていたが、なぜ rest ではないのか。
5. checksum2 は ARM のような word 境界をまたぐメモリアクセスで例外を発生させるプロセッサでは正しく動かないケースが存在する気がする。

まあ、日本語の技術書に多いことではあるけれど、編集者があまり仕事をしていない感じを常に受けながら読むことになったということ。テーマも切り口も面白かっただけにもっと良い本になっていたのではないかという思いが残った。