---
layout: post
title: "The Design and Implementation of the FreeBSD Operating System Second Edition Chapter 12.3"
date: 2015-06-06 11:09:57 +0900
comments: true
categories: book freebsd
---
## Memory Management ##

* プロセス間通信とネットワークプロトコルでのメモリ管理に対する要求は他とは少し違う
    * 効率は当然大事
    * 色々なサイズ
        * しかも可変
            * プロトコルの実装は頻繁にヘッダを付けたり削除したり
        * パケットの送受信時に分解したり組み立てたり
    * 送受信時にキューイングもしたい
* Mbufs
    * 内容によってサイズが変わるメモリバッファ
    * 全ての mbuf は固定サイズの *m_hdr* 構造体を持つ
    * データのみを持つ mbuf は 224bytes
        * 全体で 256bytes、うち *m_hdr* が 32bytes
    * 大きいメッセージの場合には外部の mbuf cluster を参照
        * x86 の場合 mbuf cluster は 2Kbytes
        * mbuf clusters は別の mbuf からもメモリ間コピーなしで参照可能
            * そのためのリファレンスカウントは外部の配列として管理され、共有する mbuf から参照される
    * データは内部、外部のどちらにも持てるが、両方同時に使うことはない
        * データへのアクセスには mbuf 内のポインタを使う
        * length の情報も持っている
            * 先頭部分のデータをトリミングするにはポインタを進めて length を減らす
            * 末尾の場合は length のみの変更
            * mbuf 内のスベースが利用可能ならデータを両端に付け加えることもできる
            * こうした性質は通信プロトコルの実装に便利
                * 上のレイヤに渡す前にプロトコルの情報をストリップできる
                * 下のレイヤに渡す前にプロトコルの情報を付加できる
    * 複数の mbufs をリンクすることも可能
        * 任意の量のデータを保持できる
        * *m_next* フィールドを使用
            * チェイン全体で一つのオブジェクトとして扱う
        * *m_nextpkt* はオブジェクトのリスト用
            * キューを構成
    * mbuf は用途によって型付けされる
        * mbuf チェイン内のメッセージがオプショナルなコンポーネントを持つか
        * ストレージの使用などの統計用、または問題発生時の mbuf 追跡用
    * mbuf のフラグは 2 種に分類される
        * 個々の mbuf に対するもの
            * 外部ストレージを参照するか (M\_EXT)
                * mbuf のデータエリアはヘッダエリアがオーバーレイされる
                    * 外部バッファの状態、サイズ等
                    * バッファ解放用のルーチンのポインタ
                        * 現在は使われていない
                * M\_EXT は M\_PKTHDR と共存可能
                    * 標準 mbuf ヘッダ、packet ヘッダ、外部ストレージヘッダの順
            * packet ヘッダフィールドを持つか (M\_PKTHDR)
                * パケットは通常先頭の mbuf に M\_PKTHDR をセットしたチェインの形で保持される
                * M\_PKTHDR があると、標準のヘッダの後に別のヘッダが続く
                    * mbuf のデータ領域は 224 bytes から 168 bytes に
                    * packet header には以下のようなフィールドがある
                        * 受け取ったインタフェースへのポインタ
                        * パケットの長さ
                        * チェックサム計算関連
                        * tags のリストへのポインタ
            * レコードが完了したか (M\_EOR)
        * mbuf チェインに対するもの。先頭の mbuf が持つ
            * ブロードキャスト (M\_BCAST)
            * マルチキャスト (M\_MCAST)
    * mbuf と cluster 用のメモリはカーネルパラメータ *maxusers* に基づく
        * 物理メモリ量を基にしているが、web サーバとかルータ用のシステムなんかは増やして使える
    * mbuf が固定サイズなのは以下の理由による
        * フラグメンテーションを少なくするため
        * 通信プロトコルは既存のデータにヘッダを加えたり、データエリアを分割したり、トリミングが必要な場合がよくある
    * tag は固定サイズの構造でメモリの一部分を指して情報をストアすることができる
        * tag は以下のものを持つ
            * リスト内の次の tag へのリンク
            * ID (16bit)
            * 長さ (16bit)
            * cookie (32bit)
                * tag を持つモジュール識別用
            * モジュールによって定義される型
        * tag はパケット内部に含まれない情報を運ぶ
            * ネットワークサブシステムの拡張によく使われる
                * 新しいネットワークモジュールは FreeBSD のバージョン間でのバイナリ互換性を損なわずに自身の tag を定義できる
                    * ネットワークスタックの異なるコンポーネント間で out-of-band 情報の通信用とか
* Storage-Management Algorithms
    * マルチプロセッサ対応で大きく書き直された
        * 各 CPU は mbuf と mbuf cluster 用に自身のプライべートなコンテナを持つ
        * CPU 毎のリストが空になった時、もしくは full で free した時用に単一のプールがある
        * mbuf アロケーションの要求時に wait できるかを指定する
            * wait できるなら、リソース利用不可の時にそのプロセスは sleep する
            * nonblocking なら fail する
            * mbuf アロケーションが制限に達した場合、ネットワークプロトコルモジュールに余っているリソースを返してもらう
        * mbuf アロケーションの要求は *m_get()*、*m_gethdr()* およびそれと等価なマクロを通じて行う
            * 現在の CPU に属するリストから *mb_alloc()* で mbuf を見付け、初期化する
            * *m_gethdr()* は packet ヘッダの初期化も行う
            * MCLGET マクロは mbuf cluster を mbuf に付ける
        * mbuf の解放
            * *m_free()* は単一の mbuf を解放
            * *m_freem()* はチェインを解放
            * mbuf が参照する mbuf cluster の解放はリファレンスカウントをデクリメント
                * 0 になったら現在の CPU のリストに戻す
* Mbuf Utility Routines
    * *m_copym()* はデータ開始からの論理オフセットを始点に mbuf チェインのコピーを作成
        * mbuf が mbuf cluster に関連付いている場合、リファレンスカウントを上げて同一のデータを参照する
    * *m_copydata()* は *m_copym()* に似ているが、mbuf チェインから指定したバッファにコピーする
    * *m_adj()* は両端からデータを削除し、mbuf チェイン内のデータを指定したバイト数に調節する
        * コピーは発生しない
    * *mtod()* マクロは mbuf ヘッダのポインタとデータ型を取り、その型にキャストしたバッファ内のデータへのポインタを返す
    * *m_pullup()* は指定したバイト数がメモリ上で連続するように mbuf チェインを再配置する
        * プロトコルヘッダのようなオブジェクトが連続していて通常のデータ構造として扱われ得るような場合に用いられる
            * 将来の呼出しを避けるために、空きがあれば *m_pullup()* はプロトコルヘッダの最大サイズまで拡大する
    * *M_PREPEND()* マクロは先頭に指定したバイト数のデータを加えるように mbuf チェインを調節する
        * 可能なときは in place で
        * そうでないときはアロケートした mbuf がチェインの先頭に付く
        * mbuf cluster 内のデータに対しては不可
            * 別の mbuf が参照しているかもしれないので
